From 741b6b65c4b8e109b3dab61040e8d27f4acbded8 Mon Sep 17 00:00:00 2001
From: amlakshm <AmmuThivya.LakshmiS@amd.com>
Date: Fri, 12 Sep 2025 05:35:43 +0000
Subject: [PATCH] bnxt_en: Extend queue stop/start for Tx rings

Since queue stop/start was only reallocating the Rx completion
ring, the Tx completions bound to the NQ ring were still arriving
with a stale Steering tag corresponding to the older CPU core.
Fix this by having the Tx rings re-allocated as part of queue stop/
start as well
---
 drivers/net/ethernet/broadcom/bnxt/bnxt.c | 66 +++++++++++++++++++++++
 1 file changed, 66 insertions(+)

diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt.c b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
index 5f2b4a09167c..1049e4d9c4cf 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@ -323,6 +323,10 @@ static bool bnxt_vf_pciid(enum board_idx idx)
 	bnxt_writeq(bp, (db)->db_key64 | DBR_TYPE_NQ_ARM |		\
 		    DB_RING_IDX(db, idx), (db)->doorbell)
 
+static int hwrm_ring_free_send_msg(struct bnxt *bp,
+                                   struct bnxt_ring_struct *ring,
+                                   u32 ring_type, int cmpl_ring_id);
+
 static void bnxt_db_nq(struct bnxt *bp, struct bnxt_db_info *db, u32 idx)
 {
 	if (bp->flags & BNXT_FLAG_CHIP_P7)
@@ -7054,6 +7058,19 @@ static void bnxt_set_db(struct bnxt *bp, struct bnxt_db_info *db, u32 ring_type,
 	}
 	bnxt_set_db_mask(bp, db, ring_type);
 }
+static int bnxt_hwrm_tx_ring_alloc(struct bnxt *bp, struct bnxt_tx_ring_info *txr,
+				   u32 tx_idx)
+{
+	struct bnxt_ring_struct *ring = &txr->tx_ring_struct;
+	u32 type = HWRM_RING_ALLOC_TX;
+	int rc;
+
+	rc = hwrm_ring_alloc_send_msg(bp, ring, type, tx_idx);
+	if (rc)
+		return rc;
+	bnxt_set_db(bp, &txr->tx_db, type, tx_idx, ring->fw_ring_id);
+	return 0;
+}
 static int bnxt_hwrm_cp_ring_alloc_p5(struct bnxt *bp, struct bnxt_cp_ring_info *cpr)
 {
 	struct bnxt_napi *bnapi = cpr->bnapi;
@@ -7235,7 +7252,25 @@ static void bnxt_cancel_dim(struct bnxt *bp)
 		cancel_work_sync(&bnapi->cp_ring.dim.work);
 	}
 }
+static void bnxt_hwrm_tx_ring_free(struct bnxt *bp, struct bnxt_tx_ring_info *txr,
+				   bool close_path)
+{
+	struct bnxt_ring_struct *ring = &txr->tx_ring_struct;
+	u32 cmpl_ring_id;
 
+	if (ring->fw_ring_id == INVALID_HW_RING_ID)
+		return;
+
+	cmpl_ring_id = close_path ? bnxt_cp_ring_for_tx(bp, txr) :
+		       INVALID_HW_RING_ID;
+#ifdef DEV_NETMAP
+	if (txr->tx_cpr->netmapped)
+		bnxt_netmap_txflush(txr);
+#endif
+	hwrm_ring_free_send_msg(bp, ring, RING_FREE_REQ_RING_TYPE_TX,
+				cmpl_ring_id);
+	ring->fw_ring_id = INVALID_HW_RING_ID;
+}
 static int hwrm_ring_free_send_msg(struct bnxt *bp,
 				   struct bnxt_ring_struct *ring,
 				   u32 ring_type, int cmpl_ring_id)
@@ -15539,12 +15574,14 @@ static int bnxt_queue_start(struct net_device *dev, void *qmem, int idx)
 {
 	struct bnxt *bp = netdev_priv(dev);
 	struct bnxt_rx_ring_info *rxr, *clone;
+	struct bnxt_tx_ring_info *txr; 
 	struct bnxt_cp_ring_info *cpr;
 	struct bnxt_vnic_info *vnic;
 	int i, rc;
 	u16 mru;
 
 	rxr = &bp->rx_ring[idx];
+	txr = &bp->tx_ring[idx]; 
 	clone = qmem;
 
 	rxr->rx_prod = clone->rx_prod;
@@ -15581,6 +15618,26 @@ static int bnxt_queue_start(struct net_device *dev, void *qmem, int idx)
 	INIT_WORK(&cpr->dim.work, bnxt_dim_work);
 	cpr->dim.mode = DIM_CQ_PERIOD_MODE_START_FROM_EQE;
  
+  /* No need to rollback if Rx ring reset has worked */
+	rc = bnxt_hwrm_cp_ring_alloc_p5(bp, txr->tx_cpr);
+	if (rc)
+		return rc;
+
+	rc = bnxt_hwrm_tx_ring_alloc(bp, txr, false);
+	if (rc) {
+		bnxt_hwrm_cp_ring_free(bp, txr->tx_cpr);
+		return rc;
+	}
+
+	txr->tx_prod = 0;
+	txr->tx_cons = 0;
+	txr->tx_hw_cons = 0;
+
+	WRITE_ONCE(txr->dev_state, 0);
+	synchronize_net();
+
+	netif_start_subqueue(bp->dev, txr->txq_index);
+ 
 	napi_enable(&rxr->bnapi->napi);
 	for (i = 0; i < bp->nr_vnics; i++) {
 		vnic = &bp->vnic_info[i];
@@ -15603,6 +15660,7 @@ static int bnxt_queue_stop(struct net_device *dev, void *qmem, int idx)
 	struct bnxt *bp = netdev_priv(dev);
 	struct bnxt_rx_ring_info *rxr;
   struct bnxt_cp_ring_info *cpr;
+  struct bnxt_tx_ring_info *txr;  
 	struct bnxt_vnic_info *vnic;
   struct bnxt_napi *bnapi;
  
@@ -15632,6 +15690,14 @@ static int bnxt_queue_stop(struct net_device *dev, void *qmem, int idx)
 
 	bnxt_free_one_cp_ring(bp, rxr->rx_cpr);
 
+	txr = &bp->tx_ring[idx];
+	WRITE_ONCE(txr->dev_state, BNXT_DEV_STATE_CLOSING);
+	synchronize_net();
+	netif_stop_subqueue(bp->dev, txr->txq_index);
+
+	bnxt_hwrm_tx_ring_free(bp, txr, false);
+	bnxt_free_one_cp_ring(bp, txr->tx_cpr);
+
 	memcpy(qmem, rxr, sizeof(*rxr));
 	bnxt_init_rx_ring_struct(bp, qmem);
 
-- 
2.43.0

