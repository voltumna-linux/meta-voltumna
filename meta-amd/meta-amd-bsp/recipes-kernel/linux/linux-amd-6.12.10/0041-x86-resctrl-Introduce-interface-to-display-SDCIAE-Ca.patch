From fbf32aa9be5fc37504a7ad94051e3ecbe95f3dbe Mon Sep 17 00:00:00 2001
From: Babu Moger <babu.moger@amd.com>
Date: Fri, 9 Aug 2024 14:53:39 -0500
Subject: [PATCH 11/12] x86/resctrl: Introduce interface to display SDCIAE
 Capacity Bit Masks

When enabled, SDCIAE forces all SDCI lines to be placed into the L3 cache
partitions identified by the highest-supported L3_MASK_n register where
n is the maximum CLOSID supported.

Add the interface to display CBMs (Capacity Bit Mask) of the SDCIAE.

Signed-off-by: Babu Moger <babu.moger@amd.com>
---
 arch/x86/kernel/cpu/resctrl/ctrlmondata.c |  2 +-
 arch/x86/kernel/cpu/resctrl/internal.h    |  1 +
 arch/x86/kernel/cpu/resctrl/rdtgroup.c    | 29 +++++++++++++++++++++++
 3 files changed, 31 insertions(+), 1 deletion(-)

diff --git a/arch/x86/kernel/cpu/resctrl/ctrlmondata.c b/arch/x86/kernel/cpu/resctrl/ctrlmondata.c
index 50fa1fe9a073..fc99f4d17e6c 100644
--- a/arch/x86/kernel/cpu/resctrl/ctrlmondata.c
+++ b/arch/x86/kernel/cpu/resctrl/ctrlmondata.c
@@ -439,7 +439,7 @@ u32 resctrl_arch_get_config(struct rdt_resource *r, struct rdt_ctrl_domain *d,
 	return hw_dom->ctrl_val[idx];
 }
 
-static void show_doms(struct seq_file *s, struct resctrl_schema *schema, int closid)
+void show_doms(struct seq_file *s, struct resctrl_schema *schema, int closid)
 {
 	struct rdt_resource *r = schema->res;
 	struct rdt_ctrl_domain *dom;
diff --git a/arch/x86/kernel/cpu/resctrl/internal.h b/arch/x86/kernel/cpu/resctrl/internal.h
index 9a3da6d49144..f2c87ca37b13 100644
--- a/arch/x86/kernel/cpu/resctrl/internal.h
+++ b/arch/x86/kernel/cpu/resctrl/internal.h
@@ -663,6 +663,7 @@ void __init thread_throttle_mode_init(void);
 void __init mbm_config_rftype_init(const char *config);
 void rdt_staged_configs_clear(void);
 void __init resctrl_sdciae_rftype_init(void);
+void show_doms(struct seq_file *s, struct resctrl_schema *schema, int closid);
 bool closid_allocated(unsigned int closid);
 int resctrl_find_cleanest_closid(void);
 
diff --git a/arch/x86/kernel/cpu/resctrl/rdtgroup.c b/arch/x86/kernel/cpu/resctrl/rdtgroup.c
index 58e4df195207..51bc715bb6ae 100644
--- a/arch/x86/kernel/cpu/resctrl/rdtgroup.c
+++ b/arch/x86/kernel/cpu/resctrl/rdtgroup.c
@@ -1922,6 +1922,25 @@ static ssize_t resctrl_sdciae_write(struct kernfs_open_file *of, char *buf,
 	return ret ?: nbytes;
 }
 
+static int resctrl_sdciae_cbm_show(struct kernfs_open_file *of,
+				   struct seq_file *seq, void *v)
+{
+	struct resctrl_schema *s = of->kn->parent->priv;
+	struct rdt_resource *r = s->res;
+	u32 sdciae_closid;
+
+	if (!resctrl_arch_get_sdciae_enabled(RDT_RESOURCE_L3)) {
+		rdt_last_cmd_puts("SDCIAE is not enabled\n");
+		return -EINVAL;
+	}
+
+	sdciae_closid = get_sdciae_closid(r);
+
+	show_doms(seq, s, sdciae_closid);
+
+	return 0;
+}
+
 /* rdtgroup information files for one cache resource. */
 static struct rftype res_common_files[] = {
 	{
@@ -2081,6 +2100,12 @@ static struct rftype res_common_files[] = {
 		.seq_show	= resctrl_sdciae_show,
 		.write		= resctrl_sdciae_write,
 	},
+	{
+		.name		= "sdciae_cbm",
+		.mode		= 0444,
+		.kf_ops		= &rdtgroup_kf_single_ops,
+		.seq_show	= resctrl_sdciae_cbm_show,
+	},
 	{
 		.name		= "mode",
 		.mode		= 0644,
@@ -2187,6 +2212,10 @@ void __init resctrl_sdciae_rftype_init(void)
 	rft = rdtgroup_get_rftype_by_name("sdciae");
 	if (rft)
 		rft->fflags = RFTYPE_CTRL_INFO | RFTYPE_RES_CACHE;
+
+	rft = rdtgroup_get_rftype_by_name("sdciae_cbm");
+	if (rft)
+		rft->fflags = RFTYPE_CTRL_INFO | RFTYPE_RES_CACHE;
 }
 
 /**
-- 
2.17.1

