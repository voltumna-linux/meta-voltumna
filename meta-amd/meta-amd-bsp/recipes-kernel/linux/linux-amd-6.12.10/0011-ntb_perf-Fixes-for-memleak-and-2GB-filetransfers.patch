From 5566abe375d53438a8813e8793e075f2295bed35 Mon Sep 17 00:00:00 2001
From: Sanath S <Sanath.S@amd.com>
Date: Fri, 18 Oct 2024 16:41:03 +0530
Subject: [PATCH 12/13] ntb_perf: Fixes for memleak and 2GB filetransfers

In case of CPU transfer, the cma allocation was not freed.
Free the cma allocation once the test is complete.

In case of filetransfer of chunk order 2GB, kernel_read
does'nt always gurantee the read of 2GB at one shot from
file. So, read the file untill you get 2GB.

Signed-off-by: Sanath S <Sanath.S@amd.com>
---
 drivers/ntb/test/ntb_perf.c | 65 ++++++++++++++++++++++---------------
 1 file changed, 38 insertions(+), 27 deletions(-)

diff --git a/drivers/ntb/test/ntb_perf.c b/drivers/ntb/test/ntb_perf.c
index d2ec1d41138c..c4e0048f7682 100644
--- a/drivers/ntb/test/ntb_perf.c
+++ b/drivers/ntb/test/ntb_perf.c
@@ -1193,11 +1193,11 @@ static int perf_run_filetest(struct perf_thread *pthr)
 	struct perf_peer *peer = pthr->perf->test_peer;
 	struct perf_ctx *perf = pthr->perf;
 	void __iomem *flt_dst, *bnd_dst;
-	u64 total_size, chunk_size, remaining_bytes;
+	u64 total_size, chunk_size, remaining_bytes, chunk;
 	void *flt_src;
 	int ret = 0;
 	struct file *f;
-	size_t padding;
+	size_t padding, bytes;
 	int tidx;
 
 	total_size = perf->total_data;
@@ -1225,9 +1225,9 @@ static int perf_run_filetest(struct perf_thread *pthr)
 	pthr->duration = ktime_get();
 
 	/* Copied field is cleared on test launch stage */
-	while (pthr->copied < total_size) {  
+	while (pthr->copied < total_size) {
 		if(flt_dst >= (peer->outbuf + max_mw_size) )
-			flt_dst = peer->outbuf;  
+			flt_dst = peer->outbuf;
 
 		for (tidx = 0; tidx < perf->dch_cnt; tidx++) {
 			if (!(pthr->copied < total_size))
@@ -1238,10 +1238,18 @@ static int perf_run_filetest(struct perf_thread *pthr)
 
 				/* Calculate padding needed for 4-byte alignment */
 				padding = (4 - (chunk_size % 4)) % 4;
-				kernel_read(f, flt_src, chunk_size, &f->f_pos);
-				chunk_size += padding; // Adjust chunk size to include padding
+				bytes = 0;
+				while (bytes < chunk_size) {
+					chunk = chunk_size - bytes;
+					bytes += kernel_read(f, flt_src + bytes, chunk, &f->f_pos);
+				}
+				chunk_size += padding;
 			} else {
-				kernel_read(f, flt_src, chunk_size, &f->f_pos);
+				bytes = 0;
+				while (bytes < chunk_size) {
+					chunk = chunk_size - bytes;
+					bytes += kernel_read(f, flt_src + bytes, chunk, &f->f_pos);
+				}
 			}
 
 			ret = perf_copy_filechunk(pthr, flt_dst, flt_src, chunk_size, tidx);
@@ -1341,28 +1349,31 @@ static int perf_sync_test(struct perf_thread *pthr)
 
 static void perf_clear_test(struct perf_thread *pthr)
 {
-	struct perf_ctx *perf = pthr->perf;
-	int tidx;
+    struct perf_ctx *perf = pthr->perf;
+    int tidx;
 
-	if (!use_dma)
-		return;
+    if (!use_dma) {
+        if (pthr->src[0]) {
+            dma_free_coherent(&perf->ntb->pdev->dev, perf->test_peer->outbuf_size, pthr->src[0], pthr->dma_src_addr[0]);
+            pthr->src[0] = NULL;
+        }
+        return;
+    }
+
+    for (tidx = 0; tidx < perf->dch_cnt; tidx++) {
+	(void)dmaengine_terminate_sync(pthr->dma_chan[tidx]);
+	if (pthr->dma_dst_addr[tidx])
+		dma_unmap_resource(pthr->dma_chan[tidx]->device->dev,
+                                          pthr->dma_dst_addr[tidx],
+                                          pthr->perf->test_peer->outbuf_size,
+                                          DMA_FROM_DEVICE, 0);
+
+        dma_free_coherent(pthr->dma_chan[tidx]->device->dev,
+                                 perf->test_peer->outbuf_size,
+                                 pthr->src[tidx], pthr->dma_src_addr[tidx]);
+        dma_release_channel(pthr->dma_chan[tidx]);
+    }
 
-	/*
-	 * If test finished without errors, termination isn't needed.
-	 * We call it anyway just to be sure of the transfers completion.
-	 */
-	for (tidx = 0; tidx < perf->dch_cnt; tidx++) {
-		(void)dmaengine_terminate_sync(pthr->dma_chan[tidx]);
-		if (pthr->dma_dst_addr[tidx])
-			dma_unmap_resource(pthr->dma_chan[tidx]->device->dev,
-					   pthr->dma_dst_addr[tidx],
-					   pthr->perf->test_peer->outbuf_size,
-					   DMA_FROM_DEVICE, 0);
-		dma_free_coherent(pthr->dma_chan[tidx]->device->dev,
-				  perf->test_peer->outbuf_size,
-				  pthr->src[tidx], pthr->dma_src_addr[tidx]);
-		dma_release_channel(pthr->dma_chan[tidx]);
-	}
 }
 
 static void perf_thread_work(struct work_struct *work)
-- 
2.39.2

