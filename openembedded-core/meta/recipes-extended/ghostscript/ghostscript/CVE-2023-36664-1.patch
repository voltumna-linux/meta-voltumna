From 5e65eeae225c7d02d447de5abaf4a8e6d234fcea Mon Sep 17 00:00:00 2001
From: Chris Liddell <chris.liddell@artifex.com>
Date: Wed, 7 Jun 2023 10:23:06 +0100
Subject: [PATCH] Bug 706761: Don't "reduce" %pipe% file names for permission validation

For regular file names, we try to simplfy relative paths before we use them.

Because the %pipe% device can, effectively, accept command line calls, we
shouldn't be simplifying that string, because the command line syntax can end
up confusing the path simplifying code. That can result in permitting a pipe
command which does not match what was originally permitted.

Special case "%pipe" in the validation code so we always deal with the entire
string.

Upstream-Status: Backport [https://git.ghostscript.com/?p=ghostpdl.git;a=commit;h=505eab7782b429017eb434b2b95120855f2b0e3c]
CVE: CVE-2023-36664
Signed-off-by: Vijay Anusuri <vanusuri@mvista.com>
---
 base/gpmisc.c   | 31 +++++++++++++++++++--------
 base/gslibctx.c | 56 ++++++++++++++++++++++++++++++++++++-------------
 2 files changed, 64 insertions(+), 23 deletions(-)

diff --git a/base/gpmisc.c b/base/gpmisc.c
index c4fffae..09ac6b3 100644
--- a/base/gpmisc.c
+++ b/base/gpmisc.c
@@ -1046,16 +1046,29 @@ gp_validate_path_len(const gs_memory_t *mem,
              && !memcmp(path + cdirstrl, dirsepstr, dirsepstrl)) {
           prefix_len = 0;
     }
-    rlen = len+1;
-    bufferfull = (char *)gs_alloc_bytes(mem->thread_safe_memory, rlen + prefix_len, "gp_validate_path");
-    if (bufferfull == NULL)
-        return gs_error_VMerror;
-
-    buffer = bufferfull + prefix_len;
-    if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)
-        return gs_error_invalidfileaccess;
-    buffer[rlen] = 0;
 
+    /* "%pipe%" do not follow the normal rules for path definitions, so we
+       don't "reduce" them to avoid unexpected results
+     */
+    if (len > 5 && memcmp(path, "%pipe", 5) != 0) {
+	bufferfull = buffer = (char *)gs_alloc_bytes(mem->thread_safe_memory, len + 1, "gp_validate_path");
+	if (buffer == NULL)
+	    return gs_error_VMerror;
+	memcpy(buffer, path, len);
+	buffer[len] = 0;
+	rlen = len;
+    }
+    else {
+	rlen = len+1;
+	bufferfull = (char *)gs_alloc_bytes(mem->thread_safe_memory, rlen + prefix_len, "gp_validate_path");
+	if (bufferfull == NULL)
+	    return gs_error_VMerror;
+
+	buffer = bufferfull + prefix_len;
+	if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)
+	    return gs_error_invalidfileaccess;
+	buffer[rlen] = 0;
+    }
     while (1) {
         switch (mode[0])
         {
diff --git a/base/gslibctx.c b/base/gslibctx.c
index 20c5eee..355c0e3 100644
--- a/base/gslibctx.c
+++ b/base/gslibctx.c
@@ -719,14 +719,28 @@ gs_add_control_path_len(const gs_memory_t *mem, gs_path_control_t type, const ch
             return gs_error_rangecheck;
     }
 
-    rlen = len+1;
-    buffer = (char *)gs_alloc_bytes(core->memory, rlen, "gp_validate_path");
-    if (buffer == NULL)
-        return gs_error_VMerror;
+    /* "%pipe%" do not follow the normal rules for path definitions, so we
+       don't "reduce" them to avoid unexpected results
+     */
+    if (len > 5 && memcmp(path, "%pipe", 5) != 0) {
+	buffer = (char *)gs_alloc_bytes(core->memory, len + 1, "gs_add_control_path_len");
+	if (buffer == NULL)
+	    return gs_error_VMerror;
+	memcpy(buffer, path, len);
+	buffer[len] = 0;
+	rlen = len;
+    }
+    else {
+	rlen = len + 1;
 
-    if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)
-        return gs_error_invalidfileaccess;
-    buffer[rlen] = 0;
+	buffer = (char *)gs_alloc_bytes(core->memory, rlen, "gs_add_control_path_len");
+	if (buffer == NULL)
+	    return gs_error_VMerror;
+
+	if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)
+	    return gs_error_invalidfileaccess;
+	buffer[rlen] = 0;
+    }
 
     n = control->num;
     for (i = 0; i < n; i++)
@@ -802,14 +816,28 @@ gs_remove_control_path_len(const gs_memory_t *mem, gs_path_control_t type, const
             return gs_error_rangecheck;
     }
 
-    rlen = len+1;
-    buffer = (char *)gs_alloc_bytes(core->memory, rlen, "gp_validate_path");
-    if (buffer == NULL)
-        return gs_error_VMerror;
+    /* "%pipe%" do not follow the normal rules for path definitions, so we
+       don't "reduce" them to avoid unexpected results
+     */
+    if (len > 5 && memcmp(path, "%pipe", 5) != 0) {
+	buffer = (char *)gs_alloc_bytes(core->memory, len + 1, "gs_remove_control_path_len");
+	if (buffer == NULL)
+	    return gs_error_VMerror;
+	memcpy(buffer, path, len);
+	buffer[len] = 0;
+	rlen = len;
+    }
+    else {
+	rlen = len+1;
 
-    if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)
-        return gs_error_invalidfileaccess;
-    buffer[rlen] = 0;
+	buffer = (char *)gs_alloc_bytes(core->memory, rlen, "gs_remove_control_path_len");
+	if (buffer == NULL)
+	    return gs_error_VMerror;
+
+	if (gp_file_name_reduce(path, (uint)len, buffer, &rlen) != gp_combine_success)
+	    return gs_error_invalidfileaccess;
+	buffer[rlen] = 0;
+    }
 
     n = control->num;
     for (i = 0; i < n; i++) {
-- 
2.25.1

