From 226e336cdceec933da2e9f72b6578c7a1bea450b Mon Sep 17 00:00:00 2001
From: Su Laus <sulau@freenet.de>
Date: Thu, 13 Oct 2022 14:33:27 +0000
Subject: [PATCH] tiffcrop subroutines require a larger buffer (fixes #271,

Upstream-Status: Backport [import from debian http://security.debian.org/debian-security/pool/updates/main/t/tiff/tiff_4.1.0+git191117-2~deb10u7.debian.tar.xz ]
CVE: CVE-2022-3570 CVE-2022-3598
Signed-off-by: Chee Yang Lee <chee.yang.lee@intel.com>

Origin: https://gitlab.com/libtiff/libtiff/-/commit/cfbb883bf6ea7bedcb04177cc4e52d304522fdff
Origin: https://gitlab.com/libtiff/libtiff/-/commit/24d3b2425af24432e0e4e2fd58b33f3b04c4bfa4
Reviewed-by: Sylvain Beucler <beuc@debian.org>
Last-Update: 2023-01-17

 #381, #386, #388, #389, #435)

---
 tools/tiffcrop.c | 209 ++++++++++++++++++++++++++---------------------
 1 file changed, 117 insertions(+), 92 deletions(-)

diff --git a/tools/tiffcrop.c b/tools/tiffcrop.c
index c7877aa..c923920 100644
--- a/tools/tiffcrop.c
+++ b/tools/tiffcrop.c
@@ -126,6 +126,7 @@ static   char tiffcrop_rev_date[] = "03-03-2010";
 
 #ifdef HAVE_STDINT_H
 # include <stdint.h>
+# include <inttypes.h>
 #endif
 
 #ifndef HAVE_GETOPT
@@ -212,6 +213,10 @@ extern int getopt(int argc, char * const argv[], const char *optstring);
 
 #define TIFF_DIR_MAX  65534
 
+/* Some conversion subroutines require image buffers, which are at least 3 bytes
+ * larger than the necessary size for the image itself. */
+#define NUM_BUFF_OVERSIZE_BYTES   3
+
 /* Offsets into buffer for margins and fixed width and length segments */
 struct offset {
   uint32  tmargin;
@@ -233,7 +238,7 @@ struct offset {
  */
 
 struct  buffinfo {
-  uint32 size;           /* size of this buffer */
+  size_t size;           /* size of this buffer */
   unsigned char *buffer; /* address of the allocated buffer */
 };
 
@@ -771,8 +776,8 @@ static int readContigTilesIntoBuffer (TIFF* in, uint8* buf,
   uint32 dst_rowsize, shift_width;
   uint32 bytes_per_sample, bytes_per_pixel;
   uint32 trailing_bits, prev_trailing_bits;
-  uint32 tile_rowsize  = TIFFTileRowSize(in);
-  uint32 src_offset, dst_offset;
+  tmsize_t tile_rowsize  = TIFFTileRowSize(in);
+  tmsize_t src_offset, dst_offset;
   uint32 row_offset, col_offset;
   uint8 *bufp = (uint8*) buf;
   unsigned char *src = NULL;
@@ -822,7 +827,7 @@ static int readContigTilesIntoBuffer (TIFF* in, uint8* buf,
       TIFFError("readContigTilesIntoBuffer", "Integer overflow when calculating buffer size.");
       exit(-1);
   }
-  tilebuf = _TIFFmalloc(tile_buffsize + 3);
+  tilebuf = _TIFFmalloc(tile_buffsize + NUM_BUFF_OVERSIZE_BYTES);
   if (tilebuf == 0)
     return 0;
   tilebuf[tile_buffsize] = 0;
@@ -986,7 +991,7 @@ static int  readSeparateTilesIntoBuffer (TIFF* in, uint8 *obuf,
   for (sample = 0; (sample < spp) && (sample < MAX_SAMPLES); sample++)
     {
     srcbuffs[sample] = NULL;
-    tbuff = (unsigned char *)_TIFFmalloc(tilesize + 8);
+    tbuff = (unsigned char *)_TIFFmalloc(tilesize + NUM_BUFF_OVERSIZE_BYTES);
     if (!tbuff)
       {
       TIFFError ("readSeparateTilesIntoBuffer", 
@@ -1181,7 +1186,8 @@ writeBufferToSeparateStrips (TIFF* out, uint8* buf,
   }
   rowstripsize = rowsperstrip * bytes_per_sample * (width + 1); 
 
-  obuf = _TIFFmalloc (rowstripsize);
+  /* Add 3 padding bytes for extractContigSamples32bits */
+  obuf = _TIFFmalloc (rowstripsize + NUM_BUFF_OVERSIZE_BYTES);
   if (obuf == NULL)
     return 1;
   
@@ -1194,7 +1200,7 @@ writeBufferToSeparateStrips (TIFF* out, uint8* buf,
       stripsize = TIFFVStripSize(out, nrows);
       src = buf + (row * rowsize);
       total_bytes += stripsize;
-      memset (obuf, '\0', rowstripsize);
+      memset (obuf, '\0',rowstripsize + NUM_BUFF_OVERSIZE_BYTES);
       if (extractContigSamplesToBuffer(obuf, src, nrows, width, s, spp, bps, dump))
         {
         _TIFFfree(obuf);
@@ -1202,10 +1208,15 @@ writeBufferToSeparateStrips (TIFF* out, uint8* buf,
 	}
       if ((dump->outfile != NULL) && (dump->level == 1))
         {
-        dump_info(dump->outfile, dump->format,"", 
+          if ((uint64_t)scanlinesize > 0x0ffffffffULL) {
+              dump_info(dump->infile, dump->format, "loadImage",
+                  "Attention: scanlinesize %"PRIu64" is larger than UINT32_MAX.\nFollowing dump might be wrong.",
+                  (uint64_t)scanlinesize);
+          }
+          dump_info(dump->outfile, dump->format,"",
                   "Sample %2d, Strip: %2d, bytes: %4d, Row %4d, bytes: %4d, Input offset: %6d", 
-                  s + 1, strip + 1, stripsize, row + 1, scanlinesize, src - buf);
-        dump_buffer(dump->outfile, dump->format, nrows, scanlinesize, row, obuf);
+                  s + 1, strip + 1, stripsize, row + 1, (uint32)scanlinesize, src - buf);
+        dump_buffer(dump->outfile, dump->format, nrows, (uint32)scanlinesize, row, obuf);
 	}
 
       if (TIFFWriteEncodedStrip(out, strip++, obuf, stripsize) < 0)
@@ -1232,7 +1243,7 @@ static int writeBufferToContigTiles (TIFF* out, uint8* buf, uint32 imagelength,
   uint32 tl, tw;
   uint32 row, col, nrow, ncol;
   uint32 src_rowsize, col_offset;
-  uint32 tile_rowsize  = TIFFTileRowSize(out);
+  tmsize_t tile_rowsize  = TIFFTileRowSize(out);
   uint8* bufp = (uint8*) buf;
   tsize_t tile_buffsize = 0;
   tsize_t tilesize = TIFFTileSize(out);
@@ -1275,9 +1286,11 @@ static int writeBufferToContigTiles (TIFF* out, uint8* buf, uint32 imagelength,
   }
   src_rowsize = ((imagewidth * spp * bps) + 7U) / 8;
 
-  tilebuf = _TIFFmalloc(tile_buffsize);
+  /* Add 3 padding bytes for extractContigSamples32bits */
+  tilebuf = _TIFFmalloc(tile_buffsize + NUM_BUFF_OVERSIZE_BYTES);
   if (tilebuf == 0)
     return 1;
+  memset(tilebuf, 0, tile_buffsize + NUM_BUFF_OVERSIZE_BYTES);
   for (row = 0; row < imagelength; row += tl)
     {
     nrow = (row + tl > imagelength) ? imagelength - row : tl;
@@ -1323,7 +1336,8 @@ static int writeBufferToSeparateTiles (TIFF* out, uint8* buf, uint32 imagelength
 				       uint32 imagewidth, tsample_t spp, 
                                        struct dump_opts * dump)
   {
-  tdata_t obuf = _TIFFmalloc(TIFFTileSize(out));
+  /* Add 3 padding bytes for extractContigSamples32bits */
+  tdata_t obuf = _TIFFmalloc(TIFFTileSize(out) + NUM_BUFF_OVERSIZE_BYTES);
   uint32 tl, tw;
   uint32 row, col, nrow, ncol;
   uint32 src_rowsize, col_offset;
@@ -1333,6 +1347,7 @@ static int writeBufferToSeparateTiles (TIFF* out, uint8* buf, uint32 imagelength
 
   if (obuf == NULL)
     return 1;
+  memset(obuf, 0, TIFFTileSize(out) + NUM_BUFF_OVERSIZE_BYTES);
 
   TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);
   TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);
@@ -1754,14 +1769,14 @@ void  process_command_opts (int argc, char *argv[], char *mp, char *mode, uint32
                       
                     *opt_offset = '\0';
                     /* convert option to lowercase */
-                    end = strlen (opt_ptr);
+                    end = (unsigned int)strlen (opt_ptr);
                     for (i = 0; i < end; i++)
                       *(opt_ptr + i) = tolower((int) *(opt_ptr + i));
                     /* Look for dump format specification */
                     if (strncmp(opt_ptr, "for", 3) == 0)
                       {
 		      /* convert value to lowercase */
-                      end = strlen (opt_offset + 1);
+                      end = (unsigned int)strlen (opt_offset + 1);
                       for (i = 1; i <= end; i++)
                         *(opt_offset + i) = tolower((int) *(opt_offset + i));
                       /* check dump format value */
@@ -2213,6 +2228,8 @@ main(int argc, char* argv[])
   size_t length;
   char   temp_filename[PATH_MAX + 16]; /* Extra space keeps the compiler from complaining */
 
+  assert(NUM_BUFF_OVERSIZE_BYTES >= 3);
+
   little_endian = *((unsigned char *)&little_endian) & '1';
 
   initImageData(&image);
@@ -3114,13 +3131,13 @@ extractContigSamples32bits (uint8 *in, uint8 *out, uint32 cols,
       /* If we have a full buffer's worth, write it out */
       if (ready_bits >= 32)
         {
-        bytebuff1 = (buff2 >> 56);
+        bytebuff1 = (uint8)(buff2 >> 56);
         *dst++ = bytebuff1;
-        bytebuff2 = (buff2 >> 48);
+        bytebuff2 = (uint8)(buff2 >> 48);
         *dst++ = bytebuff2;
-        bytebuff3 = (buff2 >> 40);
+        bytebuff3 = (uint8)(buff2 >> 40);
         *dst++ = bytebuff3;
-        bytebuff4 = (buff2 >> 32);
+        bytebuff4 = (uint8)(buff2 >> 32);
         *dst++ = bytebuff4;
         ready_bits -= 32;
                     
@@ -3495,13 +3512,13 @@ extractContigSamplesShifted32bits (uint8 *in, uint8 *out, uint32 cols,
         }
       else  /* If we have a full buffer's worth, write it out */
         {
-        bytebuff1 = (buff2 >> 56);
+        bytebuff1 = (uint8)(buff2 >> 56);
         *dst++ = bytebuff1;
-        bytebuff2 = (buff2 >> 48);
+        bytebuff2 = (uint8)(buff2 >> 48);
         *dst++ = bytebuff2;
-        bytebuff3 = (buff2 >> 40);
+        bytebuff3 = (uint8)(buff2 >> 40);
         *dst++ = bytebuff3;
-        bytebuff4 = (buff2 >> 32);
+        bytebuff4 = (uint8)(buff2 >> 32);
         *dst++ = bytebuff4;
         ready_bits -= 32;
                     
@@ -3678,10 +3695,10 @@ extractContigSamplesToTileBuffer(uint8 *out, uint8 *in, uint32 rows, uint32 cols
 static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)
 {
         uint8* bufp = buf;
-        int32  bytes_read = 0;
+        tmsize_t  bytes_read = 0;
         uint32 strip, nstrips   = TIFFNumberOfStrips(in);
-        uint32 stripsize = TIFFStripSize(in);
-        uint32 rows = 0;
+        tmsize_t stripsize = TIFFStripSize(in);
+        tmsize_t rows = 0;
         uint32 rps = TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rps);
         tsize_t scanline_size = TIFFScanlineSize(in);
 
@@ -3694,13 +3711,12 @@ static int readContigStripsIntoBuffer (TIFF* in, uint8* buf)
                 bytes_read = TIFFReadEncodedStrip (in, strip, bufp, -1);
                 rows = bytes_read / scanline_size;
                 if ((strip < (nstrips - 1)) && (bytes_read != (int32)stripsize))
-                        TIFFError("", "Strip %d: read %lu bytes, strip size %lu",
-                                  (int)strip + 1, (unsigned long) bytes_read,
-                                  (unsigned long)stripsize);
+                        TIFFError("", "Strip %"PRIu32": read %"PRId64" bytes, strip size %"PRIu64,
+                                  strip + 1, bytes_read, stripsize);
 
                 if (bytes_read < 0 && !ignore) {
-                        TIFFError("", "Error reading strip %lu after %lu rows",
-                                  (unsigned long) strip, (unsigned long)rows);
+                        TIFFError("", "Error reading strip %"PRIu32" after %"PRIu64" rows",
+                                  strip, rows);
                         return 0;
                 }
                 bufp += stripsize;
@@ -4164,13 +4180,13 @@ combineSeparateSamples32bits (uint8 *in[], uint8 *out, uint32 cols,
 	/* If we have a full buffer's worth, write it out */
 	if (ready_bits >= 32)
 	  {
-	  bytebuff1 = (buff2 >> 56);
+	  bytebuff1 = (uint8)(buff2 >> 56);
 	  *dst++ = bytebuff1;
-	  bytebuff2 = (buff2 >> 48);
+	  bytebuff2 = (uint8)(buff2 >> 48);
 	  *dst++ = bytebuff2;
-	  bytebuff3 = (buff2 >> 40);
+	  bytebuff3 = (uint8)(buff2 >> 40);
 	  *dst++ = bytebuff3;
-	  bytebuff4 = (buff2 >> 32);
+	  bytebuff4 = (uint8)(buff2 >> 32);
 	  *dst++ = bytebuff4;
 	  ready_bits -= 32;
                     
@@ -4213,10 +4229,10 @@ combineSeparateSamples32bits (uint8 *in[], uint8 *out, uint32 cols,
 	         "Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
 		 row + 1, col + 1, src_byte, src_bit, dst - out);
 
-      dump_long (dumpfile, format, "Match bits ", matchbits);
+      dump_wide (dumpfile, format, "Match bits ", matchbits);
       dump_data (dumpfile, format, "Src   bits ", src, 4);
-      dump_long (dumpfile, format, "Buff1 bits ", buff1);
-      dump_long (dumpfile, format, "Buff2 bits ", buff2);
+      dump_wide (dumpfile, format, "Buff1 bits ", buff1);
+      dump_wide (dumpfile, format, "Buff2 bits ", buff2);
       dump_byte (dumpfile, format, "Write bits1", bytebuff1);
       dump_byte (dumpfile, format, "Write bits2", bytebuff2);
       dump_info (dumpfile, format, "", "Ready bits:  %2d", ready_bits); 
@@ -4689,13 +4705,13 @@ combineSeparateTileSamples32bits (uint8 *in[], uint8 *out, uint32 cols,
 	/* If we have a full buffer's worth, write it out */
 	if (ready_bits >= 32)
 	  {
-	  bytebuff1 = (buff2 >> 56);
+	  bytebuff1 = (uint8)(buff2 >> 56);
 	  *dst++ = bytebuff1;
-	  bytebuff2 = (buff2 >> 48);
+	  bytebuff2 = (uint8)(buff2 >> 48);
 	  *dst++ = bytebuff2;
-	  bytebuff3 = (buff2 >> 40);
+	  bytebuff3 = (uint8)(buff2 >> 40);
 	  *dst++ = bytebuff3;
-	  bytebuff4 = (buff2 >> 32);
+	  bytebuff4 = (uint8)(buff2 >> 32);
 	  *dst++ = bytebuff4;
 	  ready_bits -= 32;
                     
@@ -4738,10 +4754,10 @@ combineSeparateTileSamples32bits (uint8 *in[], uint8 *out, uint32 cols,
 	         "Row %3d, Col %3d, Src byte offset %3d  bit offset %2d  Dst offset %3d",
 		 row + 1, col + 1, src_byte, src_bit, dst - out);
 
-      dump_long (dumpfile, format, "Match bits ", matchbits);
+      dump_wide (dumpfile, format, "Match bits ", matchbits);
       dump_data (dumpfile, format, "Src   bits ", src, 4);
-      dump_long (dumpfile, format, "Buff1 bits ", buff1);
-      dump_long (dumpfile, format, "Buff2 bits ", buff2);
+      dump_wide (dumpfile, format, "Buff1 bits ", buff1);
+      dump_wide (dumpfile, format, "Buff2 bits ", buff2);
       dump_byte (dumpfile, format, "Write bits1", bytebuff1);
       dump_byte (dumpfile, format, "Write bits2", bytebuff2);
       dump_info (dumpfile, format, "", "Ready bits:  %2d", ready_bits); 
@@ -4764,7 +4780,7 @@ static int readSeparateStripsIntoBuffer (TIFF *in, uint8 *obuf, uint32 length,
   {
   int i, bytes_per_sample, bytes_per_pixel, shift_width, result = 1;
   uint32 j;
-  int32  bytes_read = 0;
+  tmsize_t  bytes_read = 0;
   uint16 bps = 0, planar;
   uint32 nstrips;
   uint32 strips_per_sample;
@@ -4830,7 +4846,7 @@ static int readSeparateStripsIntoBuffer (TIFF *in, uint8 *obuf, uint32 length,
   for (s = 0; (s < spp) && (s < MAX_SAMPLES); s++)
     {
     srcbuffs[s] = NULL;
-    buff = _TIFFmalloc(stripsize + 3);
+    buff = _TIFFmalloc(stripsize + NUM_BUFF_OVERSIZE_BYTES);
     if (!buff)
       {
       TIFFError ("readSeparateStripsIntoBuffer", 
@@ -4853,7 +4869,7 @@ static int readSeparateStripsIntoBuffer (TIFF *in, uint8 *obuf, uint32 length,
       buff = srcbuffs[s];
       strip = (s * strips_per_sample) + j; 
       bytes_read = TIFFReadEncodedStrip (in, strip, buff, stripsize);
-      rows_this_strip = bytes_read / src_rowsize;
+      rows_this_strip = (uint32)(bytes_read / src_rowsize);
       if (bytes_read < 0 && !ignore)
         {
         TIFFError(TIFFFileName(in),
@@ -5860,13 +5876,14 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
   uint16   input_compression = 0, input_photometric = 0;
   uint16   subsampling_horiz, subsampling_vert;
   uint32   width = 0, length = 0;
-  uint32   stsize = 0, tlsize = 0, buffsize = 0, scanlinesize = 0;
+  tmsize_t   stsize = 0, tlsize = 0, buffsize = 0;
+  tmsize_t   scanlinesize = 0;
   uint32   tw = 0, tl = 0;       /* Tile width and length */
-  uint32   tile_rowsize = 0;
+  tmsize_t   tile_rowsize = 0;
   unsigned char *read_buff = NULL;
   unsigned char *new_buff  = NULL;
   int      readunit = 0;
-  static   uint32  prev_readsize = 0;
+  static   tmsize_t  prev_readsize = 0;
 
   TIFFGetFieldDefaulted(in, TIFFTAG_BITSPERSAMPLE, &bps);
   TIFFGetFieldDefaulted(in, TIFFTAG_SAMPLESPERPIXEL, &spp);
@@ -6168,7 +6185,7 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
         TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
         return (-1);
     }
-    read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
+    read_buff = (unsigned char *)_TIFFmalloc(buffsize + NUM_BUFF_OVERSIZE_BYTES);
   }
   else
     {
@@ -6179,11 +6196,11 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
           TIFFError("loadImage", "Unable to allocate/reallocate read buffer");
           return (-1);
       }
-      new_buff = _TIFFrealloc(read_buff, buffsize+3);
+      new_buff = _TIFFrealloc(read_buff, buffsize + NUM_BUFF_OVERSIZE_BYTES);
       if (!new_buff)
         {
 	free (read_buff);
-        read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
+        read_buff = (unsigned char *)_TIFFmalloc(buffsize + NUM_BUFF_OVERSIZE_BYTES);
         }
       else
         read_buff = new_buff;
@@ -6256,8 +6273,13 @@ loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned c
     dump_info  (dump->infile, dump->format, "", 
                 "Bits per sample %d, Samples per pixel %d", bps, spp);
 
+    if ((uint64_t)scanlinesize > 0x0ffffffffULL) {
+        dump_info(dump->infile, dump->format, "loadImage",
+            "Attention: scanlinesize %"PRIu64" is larger than UINT32_MAX.\nFollowing dump might be wrong.",
+            (uint64_t)scanlinesize);
+    }
     for (i = 0; i < length; i++)
-      dump_buffer(dump->infile, dump->format, 1, scanlinesize, 
+      dump_buffer(dump->infile, dump->format, 1, (uint32)scanlinesize, 
                   i, read_buff + (i * scanlinesize));
     }
   return (0);
@@ -7277,13 +7299,13 @@ writeSingleSection(TIFF *in, TIFF *out, struct image_data *image,
      if (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {
        TIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);
        if (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) {
-	 int inknameslen = strlen(inknames) + 1;
+	 int inknameslen = (int)strlen(inknames) + 1;
 	 const char* cp = inknames;
 	 while (ninks > 1) {
 	   cp = strchr(cp, '\0');
 	   if (cp) {
 	     cp++;
-	     inknameslen += (strlen(cp) + 1);
+	     inknameslen += ((int)strlen(cp) + 1);
 	   }
 	   ninks--;
          }
@@ -7346,23 +7368,23 @@ createImageSection(uint32 sectsize, unsigned char **sect_buff_ptr)
 
   if (!sect_buff)
     {
-    sect_buff = (unsigned char *)_TIFFmalloc(sectsize);
+    sect_buff = (unsigned char *)_TIFFmalloc(sectsize + NUM_BUFF_OVERSIZE_BYTES);
     if (!sect_buff)
     {
         TIFFError("createImageSection", "Unable to allocate/reallocate section buffer");
         return (-1);
     }
-    _TIFFmemset(sect_buff, 0, sectsize);
+    _TIFFmemset(sect_buff, 0, sectsize + NUM_BUFF_OVERSIZE_BYTES);
     }
   else
     {
     if (prev_sectsize < sectsize)
       {
-      new_buff = _TIFFrealloc(sect_buff, sectsize);
+      new_buff = _TIFFrealloc(sect_buff, sectsize + NUM_BUFF_OVERSIZE_BYTES);
       if (!new_buff)
         {
 	free (sect_buff);
-        sect_buff = (unsigned char *)_TIFFmalloc(sectsize);
+        sect_buff = (unsigned char *)_TIFFmalloc(sectsize + NUM_BUFF_OVERSIZE_BYTES);
         }
       else
         sect_buff = new_buff;
@@ -7372,7 +7394,7 @@ createImageSection(uint32 sectsize, unsigned char **sect_buff_ptr)
           TIFFError("createImageSection", "Unable to allocate/reallocate section buffer");
           return (-1);
       }
-      _TIFFmemset(sect_buff, 0, sectsize);
+      _TIFFmemset(sect_buff, 0, sectsize + NUM_BUFF_OVERSIZE_BYTES);
       }
     }
 
@@ -7403,17 +7425,17 @@ processCropSelections(struct image_data *image, struct crop_mask *crop,
     cropsize = crop->bufftotal;
     crop_buff = seg_buffs[0].buffer; 
     if (!crop_buff)
-      crop_buff = (unsigned char *)_TIFFmalloc(cropsize);
+      crop_buff = (unsigned char *)_TIFFmalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);
     else
       {
       prev_cropsize = seg_buffs[0].size;
       if (prev_cropsize < cropsize)
         {
-        next_buff = _TIFFrealloc(crop_buff, cropsize);
+        next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);
         if (! next_buff)
           {
           _TIFFfree (crop_buff);
-          crop_buff = (unsigned char *)_TIFFmalloc(cropsize);
+          crop_buff = (unsigned char *)_TIFFmalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);
           }
         else
           crop_buff = next_buff;
@@ -7426,7 +7448,7 @@ processCropSelections(struct image_data *image, struct crop_mask *crop,
       return (-1);
       }
  
-    _TIFFmemset(crop_buff, 0, cropsize);
+    _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);
     seg_buffs[0].buffer = crop_buff;
     seg_buffs[0].size = cropsize;
 
@@ -7505,17 +7527,17 @@ processCropSelections(struct image_data *image, struct crop_mask *crop,
       cropsize = crop->bufftotal;
       crop_buff = seg_buffs[i].buffer; 
       if (!crop_buff)
-        crop_buff = (unsigned char *)_TIFFmalloc(cropsize);
+        crop_buff = (unsigned char *)_TIFFmalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);
       else
         {
         prev_cropsize = seg_buffs[0].size;
         if (prev_cropsize < cropsize)
           {
-          next_buff = _TIFFrealloc(crop_buff, cropsize);
+          next_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);
           if (! next_buff)
             {
             _TIFFfree (crop_buff);
-            crop_buff = (unsigned char *)_TIFFmalloc(cropsize);
+            crop_buff = (unsigned char *)_TIFFmalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);
             }
           else
             crop_buff = next_buff;
@@ -7528,7 +7550,7 @@ processCropSelections(struct image_data *image, struct crop_mask *crop,
         return (-1);
         }
  
-      _TIFFmemset(crop_buff, 0, cropsize);
+      _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);
       seg_buffs[i].buffer = crop_buff;
       seg_buffs[i].size = cropsize;
 
@@ -7641,24 +7663,24 @@ createCroppedImage(struct image_data *image, struct crop_mask *crop,
   crop_buff = *crop_buff_ptr;
   if (!crop_buff)
     {
-    crop_buff = (unsigned char *)_TIFFmalloc(cropsize);
+    crop_buff = (unsigned char *)_TIFFmalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);
     if (!crop_buff)
     {
         TIFFError("createCroppedImage", "Unable to allocate/reallocate crop buffer");
         return (-1);
     }
-    _TIFFmemset(crop_buff, 0, cropsize);
+    _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);
     prev_cropsize = cropsize;
     }
   else
     {
     if (prev_cropsize < cropsize)
       {
-      new_buff = _TIFFrealloc(crop_buff, cropsize);
+      new_buff = _TIFFrealloc(crop_buff, cropsize + NUM_BUFF_OVERSIZE_BYTES);
       if (!new_buff)
         {
 	free (crop_buff);
-        crop_buff = (unsigned char *)_TIFFmalloc(cropsize);
+        crop_buff = (unsigned char *)_TIFFmalloc(cropsize + NUM_BUFF_OVERSIZE_BYTES);
         }
       else
         crop_buff = new_buff;
@@ -7667,7 +7689,7 @@ createCroppedImage(struct image_data *image, struct crop_mask *crop,
           TIFFError("createCroppedImage", "Unable to allocate/reallocate crop buffer");
           return (-1);
       }
-      _TIFFmemset(crop_buff, 0, cropsize);
+      _TIFFmemset(crop_buff, 0, cropsize + NUM_BUFF_OVERSIZE_BYTES);
       }
     }
 
@@ -7965,13 +7987,13 @@ writeCroppedImage(TIFF *in, TIFF *out, struct image_data *image,
      if (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {
        TIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);
        if (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) {
-	 int inknameslen = strlen(inknames) + 1;
+	 int inknameslen = (int)strlen(inknames) + 1;
 	 const char* cp = inknames;
 	 while (ninks > 1) {
 	   cp = strchr(cp, '\0');
 	   if (cp) {
 	     cp++;
-	     inknameslen += (strlen(cp) + 1);
+	     inknameslen += ((int)strlen(cp) + 1);
 	   }
 	   ninks--;
          }
@@ -8356,13 +8378,13 @@ rotateContigSamples32bits(uint16 rotation, uint16 spp, uint16 bps, uint32 width,
         }
       else /* If we have a full buffer's worth, write it out */
         {
-        bytebuff1 = (buff2 >> 56);
+        bytebuff1 = (uint8)(buff2 >> 56);
         *dst++ = bytebuff1;
-        bytebuff2 = (buff2 >> 48);
+        bytebuff2 = (uint8)(buff2 >> 48);
         *dst++ = bytebuff2;
-        bytebuff3 = (buff2 >> 40);
+        bytebuff3 = (uint8)(buff2 >> 40);
         *dst++ = bytebuff3;
-        bytebuff4 = (buff2 >> 32);
+        bytebuff4 = (uint8)(buff2 >> 32);
         *dst++ = bytebuff4;
         ready_bits -= 32;
                     
@@ -8431,12 +8453,13 @@ rotateImage(uint16 rotation, struct image_data *image, uint32 *img_width,
               return (-1);
     }
 
-  if (!(rbuff = (unsigned char *)_TIFFmalloc(buffsize)))
+  /* Add 3 padding bytes for extractContigSamplesShifted32bits */
+  if (!(rbuff = (unsigned char *)_TIFFmalloc(buffsize + NUM_BUFF_OVERSIZE_BYTES)))
     {
-    TIFFError("rotateImage", "Unable to allocate rotation buffer of %1u bytes", buffsize);
+    TIFFError("rotateImage", "Unable to allocate rotation buffer of %1u bytes", buffsize + NUM_BUFF_OVERSIZE_BYTES);
     return (-1);
     }
-  _TIFFmemset(rbuff, '\0', buffsize);
+  _TIFFmemset(rbuff, '\0', buffsize + NUM_BUFF_OVERSIZE_BYTES);
 
   ibuff = *ibuff_ptr;
   switch (rotation)
@@ -8964,13 +8987,13 @@ reverseSamples32bits (uint16 spp, uint16 bps, uint32 width,
         }
       else /* If we have a full buffer's worth, write it out */
         {
-        bytebuff1 = (buff2 >> 56);
+        bytebuff1 = (uint8)(buff2 >> 56);
         *dst++ = bytebuff1;
-        bytebuff2 = (buff2 >> 48);
+        bytebuff2 = (uint8)(buff2 >> 48);
         *dst++ = bytebuff2;
-        bytebuff3 = (buff2 >> 40);
+        bytebuff3 = (uint8)(buff2 >> 40);
         *dst++ = bytebuff3;
-        bytebuff4 = (buff2 >> 32);
+        bytebuff4 = (uint8)(buff2 >> 32);
         *dst++ = bytebuff4;
         ready_bits -= 32;
                     
@@ -9061,12 +9084,13 @@ mirrorImage(uint16 spp, uint16 bps, uint16 mirror, uint32 width, uint32 length,
     {
     case MIRROR_BOTH:
     case MIRROR_VERT: 
-             line_buff = (unsigned char *)_TIFFmalloc(rowsize);
+             line_buff = (unsigned char *)_TIFFmalloc(rowsize + NUM_BUFF_OVERSIZE_BYTES);
              if (line_buff == NULL)
                {
-	       TIFFError ("mirrorImage", "Unable to allocate mirror line buffer of %1u bytes", rowsize);
+	       TIFFError ("mirrorImage", "Unable to allocate mirror line buffer of %1u bytes", rowsize + NUM_BUFF_OVERSIZE_BYTES);
                return (-1);
                }
+             _TIFFmemset(line_buff, '\0', rowsize + NUM_BUFF_OVERSIZE_BYTES);
 
              dst = ibuff + (rowsize * (length - 1));
              for (row = 0; row < length / 2; row++)
@@ -9098,11 +9122,12 @@ mirrorImage(uint16 spp, uint16 bps, uint16 mirror, uint32 width, uint32 length,
 		}
 	      else
                 { /* non 8 bit per sample  data */
-                if (!(line_buff = (unsigned char *)_TIFFmalloc(rowsize + 1)))
+                if (!(line_buff = (unsigned char *)_TIFFmalloc(rowsize + NUM_BUFF_OVERSIZE_BYTES)))
                   {
                   TIFFError("mirrorImage", "Unable to allocate mirror line buffer");
                   return (-1);
                   }
+                _TIFFmemset(line_buff, '\0', rowsize + NUM_BUFF_OVERSIZE_BYTES);
                 bytes_per_sample = (bps + 7) / 8;
                 bytes_per_pixel  = ((bps * spp) + 7) / 8;
                 if (bytes_per_pixel < (bytes_per_sample + 1))
@@ -9114,7 +9139,7 @@ mirrorImage(uint16 spp, uint16 bps, uint16 mirror, uint32 width, uint32 length,
                   {
 		  row_offset = row * rowsize;
                   src = ibuff + row_offset;
-                  _TIFFmemset (line_buff, '\0', rowsize);
+                  _TIFFmemset (line_buff, '\0', rowsize + NUM_BUFF_OVERSIZE_BYTES);
                   switch (shift_width)
                     {
                     case 1: if (reverseSamples16bits(spp, bps, width, src, line_buff))
