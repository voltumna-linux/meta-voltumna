From 848434a81c443f59ec90d41218eba6e48a450a11 Mon Sep 17 00:00:00 2001
From: zhailiangliang <zhailiangliang@loongson.cn>
Date: Thu, 16 Mar 2023 16:16:54 +0800
Subject: [PATCH] Fix heap-buffer-overflow in function extractImageSection

CVE: CVE-2023-1916
Upstream-Status: Submitted [https://gitlab.com/libtiff/libtiff/-/commit/848434a81c443f59ec90d41218eba6e48a450a11 https://gitlab.com/libtiff/libtiff/-/merge_requests/535]
Signed-off-by: Marek Vasut <marex@denx.de>
---
 archive/tools/tiffcrop.c | 62 +++++++++++++++++++++++++++++-----------
 1 file changed, 45 insertions(+), 17 deletions(-)

--- tiff-4.1.0+git191117.orig/tools/tiffcrop.c
+++ tiff-4.1.0+git191117/tools/tiffcrop.c
@@ -5549,6 +5549,15 @@ getCropOffsets(struct image_data *image,
              crop->combined_width += (uint32)zwidth;
            else
              crop->combined_width = (uint32)zwidth;
+
+           /* When the degrees clockwise rotation is 90 or 270, check the boundary */
+           if (((crop->rotation == 90) || (crop->rotation == 270))
+               && ((crop->combined_length > image->width) || (crop->combined_width > image->length)))
+           {
+               TIFFError("getCropOffsets", "The crop size exceeds the image boundary size");
+               return -1;
+           }
+
            break;
       case EDGE_BOTTOM: /* width from left, zones from bottom to top */
            zwidth = offsets.crop_width;
@@ -5579,6 +5588,15 @@ getCropOffsets(struct image_data *image,
            else
              crop->combined_length = (uint32)zlength;
            crop->combined_width = (uint32)zwidth;
+
+           /* When the degrees clockwise rotation is 90 or 270, check the boundary */
+           if (((crop->rotation == 90) || (crop->rotation == 270))
+               && ((crop->combined_length > image->width) || (crop->combined_width > image->length)))
+           {
+               TIFFError("getCropOffsets", "The crop size exceeds the image boundary size");
+               return -1;
+           }
+
            break;
       case EDGE_RIGHT: /* zones from right to left, length from top */
            zlength = offsets.crop_length;
@@ -5606,6 +5624,15 @@ getCropOffsets(struct image_data *image,
              crop->combined_width += (uint32)zwidth;
            else
              crop->combined_width = (uint32)zwidth;
+
+           /* When the degrees clockwise rotation is 90 or 270, check the boundary */
+           if (((crop->rotation == 90) || (crop->rotation == 270))
+               && ((crop->combined_length > image->width) || (crop->combined_width > image->length)))
+           {
+               TIFFError("getCropOffsets", "The crop size exceeds the image boundary size");
+               return -1;
+           }
+
            break;
       case EDGE_TOP: /* width from left, zones from top to bottom */
       default:
@@ -5632,6 +5659,15 @@ getCropOffsets(struct image_data *image,
            else
              crop->combined_length = (uint32)zlength;
            crop->combined_width = (uint32)zwidth;
+
+           /* When the degrees clockwise rotation is 90 or 270, check the boundary */
+           if (((crop->rotation == 90) || (crop->rotation == 270))
+               && ((crop->combined_length > image->width) || (crop->combined_width > image->length)))
+           {
+               TIFFError("getCropOffsets", "The crop size exceeds the image boundary size");
+               return -1;
+           }
+
            break;
       } /* end switch statement */
 
@@ -6827,9 +6863,9 @@ extractImageSection(struct image_data *i
      * regardless of the way the data are organized in the input file.
      * Furthermore, bytes and bits are arranged in buffer according to COMPRESSION=1 and FILLORDER=1 
      */
-    img_rowsize = (((img_width * spp * bps) + 7) / 8);    /* row size in full bytes of source image */
-    full_bytes = (sect_width * spp * bps) / 8;            /* number of COMPLETE bytes per row in section */
-    trailing_bits = (sect_width * spp * bps) % 8;         /* trailing bits within the last byte of destination buffer */
+    img_rowsize = (((img_width * spp * bps) + 7) / 8);  /* row size in full bytes of source image */
+    full_bytes = (sect_width * spp * bps) / 8;          /* number of COMPLETE bytes per row in section */
+    trailing_bits = (sect_width * spp * bps) % 8;       /* trailing bits within the last byte of destination buffer */
 
 #ifdef DEVELMODE
     TIFFError ("", "First row: %d, last row: %d, First col: %d, last col: %d\n",
