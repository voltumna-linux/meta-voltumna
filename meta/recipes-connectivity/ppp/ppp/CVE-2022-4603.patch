From 2aeb41a9a3a43b11b1e46628d0bf98197ff9f141 Mon Sep 17 00:00:00 2001
From: Paul Mackerras <paulus@ozlabs.org>
Date: Thu, 29 Dec 2022 18:00:20 +0100
Subject: [PATCH] pppdump: Avoid out-of-range access to packet buffer

This fixes a potential vulnerability where data is written to spkt.buf
and rpkt.buf without a check on the array index.  To fix this, we
check the array index (pkt->cnt) before storing the byte or
incrementing the count.  This also means we no longer have a potential
signed integer overflow on the increment of pkt->cnt.

Fortunately, pppdump is not used in the normal process of setting up a
PPP connection, is not installed setuid-root, and is not invoked
automatically in any scenario that I am aware of.

Ustream-Status: Backport [https://github.com/ppp-project/ppp/commit/a75fb7b198eed50d769c80c36629f38346882cbf]
CVE: CVE-2022-4603
Signed-off-by:Minjae Kim <flowergom@gmail.com>
---
 pppdump/pppdump.c | 7 ++++++-
 1 file changed, 6 insertions(+), 1 deletion(-)

diff --git a/pppdump/pppdump.c b/pppdump/pppdump.c
index 87c2e8f..dec4def 100644
--- a/pppdump/pppdump.c
+++ b/pppdump/pppdump.c
@@ -296,6 +296,10 @@ dumpppp(f)
 			    printf("%s aborted packet:\n     ", dir);
 			    q = "    ";
 			}
+			if (pkt->cnt >= sizeof(pkt->buf)) {
+			    printf("%s over-long packet truncated:\n     ", dir);
+			    q = "    ";
+			}
 			nb = pkt->cnt;
 			p = pkt->buf;
 			pkt->cnt = 0;
@@ -399,7 +403,8 @@ dumpppp(f)
 			c ^= 0x20;
 			pkt->esc = 0;
 		    }
-		    pkt->buf[pkt->cnt++] = c;
+		    if (pkt->cnt < sizeof(pkt->buf))
+			    pkt->buf[pkt->cnt++] = c;
 		    break;
 		}
 	    }
-- 
2.25.1

