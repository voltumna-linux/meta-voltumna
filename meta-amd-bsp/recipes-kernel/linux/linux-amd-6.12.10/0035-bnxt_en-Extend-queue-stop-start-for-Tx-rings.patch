From c871101ffc7ca4e18edc35296f93cd57eb1f18c8 Mon Sep 17 00:00:00 2001
From: amlakshm <AmmuThivya.LakshmiS@amd.com>
Date: Wed, 12 Feb 2025 09:35:27 +0000
Subject: [PATCH] bnxt_en: Extend queue stop/start for Tx rings

Since queue stop/start was only reallocating the Rx completion
ring, the Tx completions bound to the NQ ring were still arriving
with a stale Steering tag corresponding to the older CPU core.
Fix this by having the Tx rings re-allocated as part of queue stop/
start as well

Signed-off-by: Somnath Kotur <somnath.kotur@broadcom.com>
---
 drivers/net/ethernet/broadcom/bnxt/bnxt.c | 66 +++++++++++++++++++++++
 1 file changed, 66 insertions(+)

diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt.c b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
index e98bde21ea20..d2b5e1f7e0bb 100644
--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c
+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c
@@ -323,6 +323,10 @@ static bool bnxt_vf_pciid(enum board_idx idx)
 	bnxt_writeq(bp, (db)->db_key64 | DBR_TYPE_NQ_ARM |		\
 		    DB_RING_IDX(db, idx), (db)->doorbell)
 
+static int hwrm_ring_free_send_msg(struct bnxt *bp,
+                                   struct bnxt_ring_struct *ring,
+                                   u32 ring_type, int cmpl_ring_id);
+
 static void bnxt_db_nq(struct bnxt *bp, struct bnxt_db_info *db, u32 idx)
 {
 	if (bp->flags & BNXT_FLAG_CHIP_P7)
@@ -6983,6 +6987,19 @@ static void bnxt_set_db(struct bnxt *bp, struct bnxt_db_info *db, u32 ring_type,
 	}
 	bnxt_set_db_mask(bp, db, ring_type);
 }
+static int bnxt_hwrm_tx_ring_alloc(struct bnxt *bp, struct bnxt_tx_ring_info *txr,
+				   u32 tx_idx)
+{
+	struct bnxt_ring_struct *ring = &txr->tx_ring_struct;
+	u32 type = HWRM_RING_ALLOC_TX;
+	int rc;
+
+	rc = hwrm_ring_alloc_send_msg(bp, ring, type, tx_idx);
+	if (rc)
+		return rc;
+	bnxt_set_db(bp, &txr->tx_db, type, tx_idx, ring->fw_ring_id);
+	return 0;
+}
 static int bnxt_hwrm_cp_ring_alloc_p5(struct bnxt *bp, struct bnxt_cp_ring_info *cpr)
 {
 	struct bnxt_napi *bnapi = cpr->bnapi;
@@ -7164,7 +7181,25 @@ static void bnxt_cancel_dim(struct bnxt *bp)
 		cancel_work_sync(&bnapi->cp_ring.dim.work);
 	}
 }
+static void bnxt_hwrm_tx_ring_free(struct bnxt *bp, struct bnxt_tx_ring_info *txr,
+				   bool close_path)
+{
+	struct bnxt_ring_struct *ring = &txr->tx_ring_struct;
+	u32 cmpl_ring_id;
+
+	if (ring->fw_ring_id == INVALID_HW_RING_ID)
+		return;
 
+	cmpl_ring_id = close_path ? bnxt_cp_ring_for_tx(bp, txr) :
+		       INVALID_HW_RING_ID;
+#ifdef DEV_NETMAP
+	if (txr->tx_cpr->netmapped)
+		bnxt_netmap_txflush(txr);
+#endif
+	hwrm_ring_free_send_msg(bp, ring, RING_FREE_REQ_RING_TYPE_TX,
+				cmpl_ring_id);
+	ring->fw_ring_id = INVALID_HW_RING_ID;
+}
 static int hwrm_ring_free_send_msg(struct bnxt *bp,
 				   struct bnxt_ring_struct *ring,
 				   u32 ring_type, int cmpl_ring_id)
@@ -15380,11 +15415,13 @@ static int bnxt_queue_start(struct net_device *dev, void *qmem, int idx)
 {
 	struct bnxt *bp = netdev_priv(dev);
 	struct bnxt_rx_ring_info *rxr, *clone;
+	struct bnxt_tx_ring_info *txr;
 	struct bnxt_cp_ring_info *cpr;
 	struct bnxt_vnic_info *vnic;
 	int i, rc;
 
 	rxr = &bp->rx_ring[idx];
+	txr = &bp->tx_ring[idx];
 	clone = qmem;
 
 	rxr->rx_prod = clone->rx_prod;
@@ -15416,6 +15453,26 @@ static int bnxt_queue_start(struct net_device *dev, void *qmem, int idx)
 	INIT_WORK(&cpr->dim.work, bnxt_dim_work);
 	cpr->dim.mode = DIM_CQ_PERIOD_MODE_START_FROM_EQE;
 
+	/* No need to rollback if Rx ring reset has worked */
+	rc = bnxt_hwrm_cp_ring_alloc_p5(bp, txr->tx_cpr);
+	if (rc)
+		return rc;
+
+	rc = bnxt_hwrm_tx_ring_alloc(bp, txr, false);
+	if (rc) {
+		bnxt_hwrm_cp_ring_free(bp, txr->tx_cpr);
+		return rc;
+	}
+
+	txr->tx_prod = 0;
+	txr->tx_cons = 0;
+	txr->tx_hw_cons = 0;
+
+	WRITE_ONCE(txr->dev_state, 0);
+	synchronize_net();
+
+	netif_start_subqueue(bp->dev, txr->txq_index);
+
 	napi_enable(&rxr->bnapi->napi);
 	for (i = 0; i <= BNXT_VNIC_NTUPLE; i++) {
 		vnic = &bp->vnic_info[i];
@@ -15443,6 +15500,7 @@ static int bnxt_queue_stop(struct net_device *dev, void *qmem, int idx)
 {
 	struct bnxt *bp = netdev_priv(dev);
 	struct bnxt_rx_ring_info *rxr;
+	struct bnxt_tx_ring_info *txr;
 	struct bnxt_cp_ring_info *cpr;
 	struct bnxt_vnic_info *vnic;
 	struct bnxt_napi *bnapi;
@@ -15469,6 +15527,14 @@ static int bnxt_queue_stop(struct net_device *dev, void *qmem, int idx)
 
 	bnxt_free_one_cp_ring(bp, rxr->rx_cpr);
 
+	txr = &bp->tx_ring[idx];
+	WRITE_ONCE(txr->dev_state, BNXT_DEV_STATE_CLOSING);
+	synchronize_net();
+	netif_stop_subqueue(bp->dev, txr->txq_index);
+
+	bnxt_hwrm_tx_ring_free(bp, txr, false);
+	bnxt_free_one_cp_ring(bp, txr->tx_cpr);
+
 	memcpy(qmem, rxr, sizeof(*rxr));
 	bnxt_init_rx_ring_struct(bp, qmem);
 
-- 
2.34.1

