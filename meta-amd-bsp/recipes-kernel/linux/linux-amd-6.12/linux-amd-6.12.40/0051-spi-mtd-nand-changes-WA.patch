From 4b69b2842f507c3e360487ddfb2ff850791ab95a Mon Sep 17 00:00:00 2001
From: Kalyan Rankireddy <Kalyan.Rankireddy@amd.com>
Date: Tue, 8 Oct 2024 12:45:01 +0530
Subject: [PATCH 08/12] spi: mtd nand changes - WA

Add changes to probe spinand mtd driver. This patch also includes
changes in winbond and macronix driver files.

Signed-off-by: Akshata MukundShetty <akshata.mukundshetty@amd.com>
Signed-off-by: Kalyan Rankireddy <Kalyan.Rankireddy@amd.com>
Change-Id: I5df847f3fc5acbdf723e873f4c8deaf0adfa2a72
Signed-off-by: amlakshm <AmmuThivya.LakshmiS@amd.com>
---
 drivers/mtd/nand/spi/core.c     | 161 +++++++++++++++++++++++++++++++-
 drivers/mtd/nand/spi/macronix.c |   5 +-
 drivers/mtd/nand/spi/winbond.c  |   9 ++
 drivers/spi/spi.c               |  35 +++++++
 include/linux/spi/spi.h         |   2 +
 5 files changed, 209 insertions(+), 3 deletions(-)

diff --git a/drivers/mtd/nand/spi/core.c b/drivers/mtd/nand/spi/core.c
index 241f6a4df16c..053f69ac6eba 100644
--- a/drivers/mtd/nand/spi/core.c
+++ b/drivers/mtd/nand/spi/core.c
@@ -1520,6 +1520,8 @@ static int spinand_probe(struct spi_mem *mem)
 	mutex_init(&spinand->lock);
 	mtd = spinand_to_mtd(spinand);
 	mtd->dev.parent = &mem->spi->dev;
+	/* Set required frequency supported by both master and slave */
+	mem->spi->max_speed_hz = 50000000;
 
 	ret = spinand_init(spinand);
 	if (ret)
@@ -1580,7 +1582,164 @@ static struct spi_mem_driver spinand_drv = {
 	.probe = spinand_probe,
 	.remove = spinand_remove,
 };
-module_spi_mem_driver(spinand_drv);
+//module_spi_mem_driver(spinand_drv);
+
+#define MAX_CMD_SIZE                    6
+static struct class *spimem_dev_class;
+
+struct spimem_drv {
+	struct spi_mem *spimem;
+
+	u8 command[MAX_CMD_SIZE];
+
+	dev_t                   devt;
+	spinlock_t              spi_lock;
+	struct spi_device       *spi;
+	struct list_head        device_entry;
+	struct completion       done;
+
+	struct mutex            buf_lock;
+	unsigned int            users;
+};
+
+static LIST_HEAD(device_list);
+static DEFINE_MUTEX(device_list_lock);
+
+#define SPIMEM_DRV_VERSION "0.1"
+#define SPINAND_DEV_MAJOR                153
+#define N_SPI_MINORS                    32
+
+#define SPI_BUS         2
+#define SPI_BUS_CS1     1
+
+static int spimem_dev_open(struct inode *inode, struct file *filp)
+{
+	struct spimem_drv *flash;
+	int status = -ENXIO;
+
+	mutex_lock(&device_list_lock);
+
+	list_for_each_entry(flash, &device_list, device_entry) { //device_list and device_entry
+		if (flash->devt == inode->i_rdev) {
+			status = 0;
+			break;
+		}
+	}
+	if (status == 0) {
+		if (status == 0) {
+			flash->users++;
+			filp->private_data = flash;
+			nonseekable_open(inode, filp);
+		}
+	} else {
+		pr_debug("spimem_drv: nothing for minor %d\n", iminor(inode));
+	}
+
+	mutex_unlock(&device_list_lock);
+
+	return status;
+}
+
+static int spimem_dev_release(struct inode *inode, struct file *filp)
+{
+	struct spimem_drv *flash;
+	int status = 0;
+
+	mutex_lock(&device_list_lock);
+	flash = filp->private_data;
+	filp->private_data = NULL;
+
+	/* last close? */
+	flash->users--;
+	if (!flash->users) {
+		int dofree;
+
+		/* ... after we unbound from the underlying device? */
+		spin_lock_irq(&flash->spi_lock);
+		dofree = (flash->spi == NULL);
+		spin_unlock_irq(&flash->spi_lock);
+
+		if (dofree)
+			kfree(flash);
+	}
+	mutex_unlock(&device_list_lock);
+
+	return status;
+}
+
+static const struct file_operations spinand_dev_fops = {
+	.owner = THIS_MODULE,
+	.open = spimem_dev_open,
+	.release = spimem_dev_release,
+};
+
+static int __init add_spi_device_to_bus(void)
+{
+	struct spi_controller *spi_master;
+	struct spi_device *spi_device;
+	struct spi_board_info spi_info;
+	spi_master = spi_busnum_to_master(SPI_BUS);
+	if (!spi_master) {
+		pr_info("Please make sure to modprobe spi_amd driver first\n");
+		return -1;
+	}
+	memset(&spi_info, 0, sizeof(struct spi_board_info));
+	strscpy(spi_info.modalias, "spi-nand", SPI_NAME_SIZE);
+	spi_info.bus_num = SPI_BUS; //Bus number of SPI master
+	spi_info.chip_select = SPI_BUS_CS1; //CS on which SPI device is connected
+	spi_info.mode = SPI_TX_QUAD | SPI_RX_QUAD;
+	spi_device = spi_new_device(spi_master, &spi_info);
+	if (!spi_device) {
+		pr_info("Failed here\n");
+		return -ENODEV;
+	}
+	return 0;
+}
+
+static int __init spinand_drv_init(void)
+{
+	int status;
+
+	pr_info("AMD SPINAND Driver v%s\n", SPIMEM_DRV_VERSION);
+
+	BUILD_BUG_ON(N_SPI_MINORS > 256);
+	status = register_chrdev(SPINAND_DEV_MAJOR, "mtd", &spinand_dev_fops);
+	if (status < 0)
+		return status;
+
+	spimem_dev_class = class_create("spi-nand");
+	if (IS_ERR(spimem_dev_class)) {
+		pr_info("class_create failed\n");
+		unregister_chrdev(SPINAND_DEV_MAJOR, spinand_drv.spidrv.driver.name);
+		return PTR_ERR(spimem_dev_class);
+	}
+
+	status = spi_mem_driver_register(&spinand_drv);
+	if (status < 0) {
+		pr_info("spi_register_driver failed\n");
+		class_destroy(spimem_dev_class);
+		unregister_chrdev(SPINAND_DEV_MAJOR, spinand_drv.spidrv.driver.name);
+	}
+
+	status = add_spi_device_to_bus();
+	if (status < 0) {
+		pr_info("add_spi_device_to_bus failed\n");
+		spi_mem_driver_unregister(&spinand_drv);
+		class_destroy(spimem_dev_class);
+		unregister_chrdev(SPINAND_DEV_MAJOR, spinand_drv.spidrv.driver.name);
+	}
+
+	return status;
+}
+module_init(spinand_drv_init);
+
+static void __exit spinand_drv_exit(void)
+{
+	spi_mem_driver_unregister(&spinand_drv);
+	class_destroy(spimem_dev_class);
+	unregister_chrdev(SPINAND_DEV_MAJOR, spinand_drv.spidrv.driver.name);
+}
+module_exit(spinand_drv_exit);
 
 MODULE_DESCRIPTION("SPI NAND framework");
 MODULE_AUTHOR("Peter Pan<peterpandong@micron.com>");
diff --git a/drivers/mtd/nand/spi/macronix.c b/drivers/mtd/nand/spi/macronix.c
index d277c3220fdc..71b7eb16805f 100644
--- a/drivers/mtd/nand/spi/macronix.c
+++ b/drivers/mtd/nand/spi/macronix.c
@@ -26,17 +26,18 @@ struct macronix_priv {
 };
 
 static SPINAND_OP_VARIANTS(read_cache_variants,
+		SPINAND_PAGE_READ_FROM_CACHE_QUADIO_OP(0, 2, NULL, 0),
 		SPINAND_PAGE_READ_FROM_CACHE_X4_OP(0, 1, NULL, 0),
 		SPINAND_PAGE_READ_FROM_CACHE_X2_OP(0, 1, NULL, 0),
 		SPINAND_PAGE_READ_FROM_CACHE_OP(true, 0, 1, NULL, 0),
 		SPINAND_PAGE_READ_FROM_CACHE_OP(false, 0, 1, NULL, 0));
 
 static SPINAND_OP_VARIANTS(write_cache_variants,
-		SPINAND_PROG_LOAD_X4(true, 0, NULL, 0),
+		//SPINAND_PROG_LOAD_X4(true, 0, NULL, 0),
 		SPINAND_PROG_LOAD(false, 0, NULL, 0));
 
 static SPINAND_OP_VARIANTS(update_cache_variants,
-		SPINAND_PROG_LOAD_X4(false, 0, NULL, 0),
+		//SPINAND_PROG_LOAD_X4(false, 0, NULL, 0),
 		SPINAND_PROG_LOAD(false, 0, NULL, 0));
 
 static int mx35lfxge4ab_ooblayout_ecc(struct mtd_info *mtd, int section,
diff --git a/drivers/mtd/nand/spi/winbond.c b/drivers/mtd/nand/spi/winbond.c
index a33ad04e99cc..4dede20fdbb0 100644
--- a/drivers/mtd/nand/spi/winbond.c
+++ b/drivers/mtd/nand/spi/winbond.c
@@ -252,6 +252,15 @@ static const struct spinand_info winbond_spinand_table[] = {
 					      &update_cache_variants),
 		     0,
 		     SPINAND_ECCINFO(&w25n02kv_ooblayout, w25n02kv_ecc_get_status)),
+	SPINAND_INFO("W25N04KWZEIR",
+                     SPINAND_ID(SPINAND_READID_METHOD_OPCODE_DUMMY, 0xba, 0x23),
+                     NAND_MEMORG(1, 2048, 128, 64, 4096, 80, 1, 1, 1),
+                     NAND_ECCREQ(8, 512),
+                     SPINAND_INFO_OP_VARIANTS(&read_cache_variants,
+                                             &write_cache_variants,
+                                             &update_cache_variants),
+                     SPINAND_HAS_QE_BIT,
+                     SPINAND_ECCINFO(&w25n02kv_ooblayout, w25n02kv_ecc_get_status)),
 };
 
 static int winbond_spinand_init(struct spinand_device *spinand)
diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c
index 8d6341b0d866..c1940871d468 100644
--- a/drivers/spi/spi.c
+++ b/drivers/spi/spi.c
@@ -4603,6 +4603,41 @@ int spi_sync(struct spi_device *spi, struct spi_message *message)
 }
 EXPORT_SYMBOL_GPL(spi_sync);
 
+static int __spi_controller_match(struct device *dev, const void *data)
+{
+	struct spi_controller *ctlr;
+	const u16 *bus_num = data;
+
+	ctlr = container_of(dev, struct spi_controller, dev);
+	return ctlr->bus_num == *bus_num;
+}
+
+/*
+ * spi_busnum_to_master - look up master associated with bus_num
+ * @bus_num: the master's bus number
+ * Context: can sleep
+ *
+ * This call may be used with devices that are registered after
+ * arch init time.  It returns a refcounted pointer to the relevant
+ * spi_controller (which the caller must release), or NULL if there is
+ * no such master registered.
+ *
+ * Return: the SPI master structure on success, else NULL.
+ */
+struct spi_controller *spi_busnum_to_master(u16 bus_num)
+{
+	struct device           *dev;
+	struct spi_controller   *ctlr = NULL;
+
+	dev = class_find_device(&spi_master_class, NULL, &bus_num,
+			__spi_controller_match);
+	if (dev)
+		ctlr = container_of(dev, struct spi_controller, dev);
+	/* reference got in class_find_device */
+	return ctlr;
+}
+EXPORT_SYMBOL_GPL(spi_busnum_to_master);
+
 /**
  * spi_sync_locked - version of spi_sync with exclusive bus usage
  * @spi: device with which data will be exchanged
diff --git a/include/linux/spi/spi.h b/include/linux/spi/spi.h
index 71ad766932d3..b3cb47781a78 100644
--- a/include/linux/spi/spi.h
+++ b/include/linux/spi/spi.h
@@ -803,6 +803,7 @@ static inline bool spi_controller_is_target(struct spi_controller *ctlr)
 /* PM calls that need to be issued by the driver */
 extern int spi_controller_suspend(struct spi_controller *ctlr);
 extern int spi_controller_resume(struct spi_controller *ctlr);
+extern struct spi_controller *spi_busnum_to_master(u16 busnum);
 
 /* Calls the driver make to interact with the message queue */
 extern struct spi_message *spi_get_next_queued_message(struct spi_controller *ctlr);
@@ -915,6 +916,7 @@ static inline int acpi_spi_count_resources(struct acpi_device *adev)
 }
 #endif
 
+extern struct spi_controller *spi_busnum_to_master(u16 busnum);
 /*
  * SPI resource management while processing a SPI message
  */
-- 
2.43.0

